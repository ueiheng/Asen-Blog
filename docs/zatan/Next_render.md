## 一、NEXT.JS 渲染最佳实践
在React 生态中，SSR 做得最好的可能是 Next.js，但 SSR 并不是Next.js的全部，这只是它提供的预渲染支持之一。除此之外，Next.js 提供了Web 应用生产环境所需的所有功能以及最佳实践，包括构建时预渲染、服务端渲染、路由预加载、智能打包、基于文件的路由，并且零配置开箱即用等。

在现代Web 开发里，最简单的单页应用渲染方式是 CSR, 整个系统只有一个入口 html, 这个html 没有任何内容，需要通过网络请求 JS bundle 并渲染，整个渲染过程都在客户端完成，所以叫客户端渲染。除了 SEO 问题外，在性能方面，还存在白屏时间过长的问题，在 JS bundle 返回之前，页面一直是空白的。NEXT.js 提供三种渲染模式

## SSR

Next.js 提供 getServerSideProps 函数，可以在服务端直接获取数据，同构渲染当前用户访问的页面，返回的 HTML 直接包含页面具体内容

优点：相比于客户端渲染，SSR可以降低白屏时间，提高首屏速度，提高用户的体验。

缺点：需要一个服务器承载页面的实时请求、渲染和响应，用户的每次访问都需要SSR服务进行响应，对于一些较为静态场景，比如博客、官网等，它们的内容相对来说比较确定，变化不频繁，每次通过服务端渲染出来的内容都是一样的，无疑浪费了很多没必要的服务器资源。

## SSG

可以称之为预渲染
NEXT.js 支持动态内容静态化，可以在 Web 应用编译构建时生成静态 HTML，之后将相应的HTML、CSS、JS文件上传至CDN，大大加快网页性能。NEXT.js 提供两个 getStaticPaths、getStaticProps API 在编译时获取数据生成网页链接（PS: 例如对于博客内容，/blog/:id, 在 CSR 或者 SSR 里，这都是一个页面，根据不同的id, 动态渲染不同的博客内容

SSG 的优点是能很好解决了白屏时间过长和 SEO 不友好的问题，大大降低服务器的压力。

但是它适用范围较窄，仅仅适合于页面内容较为静态的场景，面对页面数据更新频繁或页面数量很多的情况就不适合，例如商品详情页、歌曲详情页，假设有1000万个商品，会使得构建时间超长。

## ISR

ISR(Incremental Static Regeneration) 是 NEXT.js 新支持的方式，也称为增量渲染，结合 SSR + SSG, 既可以在构建时生成静态页面，也可以在运行时, 在SSR的基础上不仅给用户返回 HTML, 也会将该内容静态化，在页面有效期内，用户再次访问会直接访问到静态的 HTML。只需要在 getStaticProps 函数返回的对象中增加 revalidate 属性，就可以开启 ISR。

适应场景： 尽管SSG可以很好的将页面静态资源进行提前进行构建并部署到CDN来提高用户访问效率，但如果需要生成的页面过多比如有十几万个那么很难在服务端一次性生成，这时就需要使用到ISR做增量渲染。

## CSR

打包的时候生成只有css、js等外链标签的空白页面，客户端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，客户端获取到页面后，在加载完js后才通过js来渲染页面内容。

优点：服务器压力小
缺点：首屏渲染非常慢，需要客户端加载完js后，再来渲染页面内容。

总结：
1. SSG: 构建时生成html，直接在用户发起request时将html返回，且异步加载该页面所需的js代码。
2. SSR: 不会直接生成html，而是用户发送请求后，获取所需的数据信息，在服务端进行动态渲染。
3. ISR: 用于处理大批量页面，可以设置页面级别，结合了SSR和SSG的功能。
4. CSR: 如果应用很大，或者客户的连接速度很慢，加载时间过长，用户体验就不太好。

Next.js核心就是用来进行服务端渲染的一个框架，而服务端渲染本质上就是用来解决网站SEO不友好以及白屏加载的问题，属于网站的性能优化的一小部分，对于大多数网站，使用SSG配合客户端渲染就足以，比如淘宝PC端、阿里国际站首页，但对数据实时性要求较高的场景，比如知乎首页、掘金文章详情这样的博客系统类型网站都是使用SSR进行服务端渲染来实现。

## 团队前人总结

有动态内容吗？没有什么也不用做，直接写 React 组件，自动渲染为 HTML。

有动态内容

动态内容的数量是固定的吗？能在编译时确定动态内容的数量吗？SSG

动态内容数量庞大但不是实时更新，或者能容忍一定的过期时间。ISR

动态内容跟客户端相关吗？只能 CSR

动态内容跟请求/用户相关吗？相关就只能用服务端渲染 SSR